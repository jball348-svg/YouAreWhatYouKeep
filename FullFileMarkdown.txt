# You Are What You Keep â€” Project Progress Document

> This document is a living record of everything built so far. It contains the full game manifesto, all technical decisions, every script created, and the current state of the project. It is designed to allow any developer or LLM to pick up exactly where work left off.

---

## Quick State Summary

| Item | Status |
|------|--------|
| Unity Version | Latest LTS with URP (Universal Render Pipeline) |
| Input System | New Unity Input System (package installed) |
| Version Control | Git + GitHub, managed via GitHub Desktop |
| Current Phase | Phase 3 complete â€” Memory System data layer built |
| Next Phase | Phase 4 â€” Memory UI (visible slots, interaction) |

---

## Part 1 â€” Game Manifesto

### Working Title
**You Are What You Keep**

### Core Philosophy
This game is built around a single idea: the goal is not to win â€” the goal is to live a meaningful life inside a system.

It rejects traditional progression loops (XP, loot, grinding) in favour of:
- Emotional payoff
- Player-authored meaning
- Systemic emergence

The game should create memories, not milestones. If a player remembers a quiet sunset, a risky jump, or a strange decision they made â€” the game has succeeded.

### Player Objective
There is no explicit "win state." Instead, the player is trying to:
- Live an interesting life
- Accumulate meaningful moments
- Shape who they become through what they experience

The implicit objective: become someone worth remembering â€” even if only to yourself. Endings are reflective, not victorious.

---

### Design Pillars

**1. Moments > Progression**
The primary reward is a felt experience: awe, regret, nostalgia, calm, pride. No dopamine treadmills. No loot explosions. If a mechanic exists, it must serve a moment.

**2. Identity as Inventory**
The player does not collect items. They collect memories, traits, and ways of being. Your "build" is what you've lived, what you've kept, what you've let go of. Identity is fluid and player-authored.

**3. Time as Gentle Pressure**
Time is always present but not punishing. It should feel bittersweet, inevitable, motivating. Time creates meaning by making things finite.

**4. Systems That Respect the Player**
The game should avoid over-explaining, trust player interpretation, and allow ambiguity. Meaning emerges through interaction, not instruction.

**5. Self-Authored Reward**
The best moments are not scripted. The game should enable useless but beautiful actions, personal rituals, and quiet discovery.

---

### Core Mechanics

**Memories as Inventory**
Players collect memories instead of items. Each memory occupies a limited slot, subtly alters gameplay or perception, and shapes identity. Constraints create meaning â€” you cannot keep everything. Forgetting is a mechanic.

Example memories:
- "Swam at midnight"
- "Played guitar in the rain"
- "Got lost in the woods"

**Limited Inner Space**
The player has 5â€“8 memory slots. This creates emotional tradeoffs, personal curation, and identity evolution. Letting go of a memory should feel significant.

**Moments That Transform You**
Certain experiences permanently change the player:
- A near-death fall â†’ fearlessness or fragility
- Performing publicly â†’ confidence aura
- Deep solitude â†’ calm perception

Transformation replaces levelling.

**Time as Transformation, Not Failure**
Time passing should shift the world, change abilities, and close and open possibilities. Not punish or rush artificially. Aging is texture, not a penalty.

**The World Remembers**
Meaningful player actions leave subtle echoes:
- A place where you linger becomes warmer
- A dangerous jump becomes a local legend
- Music played somewhere lingers faintly later

**Skills as Lived Experience**
Skills are not learned through menus. They emerge from behaviour and fade when abandoned:
- Climb often â†’ natural agility
- Sit quietly â†’ heightened awareness
- Help others â†’ social warmth

---

### Reward Systems (Non-Traditional)

**Aesthetic Rewards:** Music swelling dynamically, light changing during meaningful moments, camera subtly acknowledging beauty.

**Emotional Payoffs:** Moments designed to evoke bittersweet reflection, personal pride, quiet melancholy, wonder.

**Reflective Endings:** Endings function like a memory collage, a quiet epilogue, a reflection of how you lived. Different players see different lives.

**Player-Defined Success:** The game never tells you "you did it right."

---

### Practical Gameplay Structures

**Small, Dense Worlds:** Intimate environments, highly interactive spaces, places designed for lingering. Think "walkable poetry."

**Subtle Systemic Feedback:** When players do something meaningful â€” audio layers build, colour grading shifts, time dilation occurs, environmental reactions emerge.

**Gentle Constraints:** Limited memory slots, finite time, changing body/abilities.

**Replayability Through Identity:** Each playthrough creates a different person, different memories, different endings.

---

### Tone and Aesthetic Direction

**Emotional Tone:** Warm, reflective, slightly melancholic, hopeful. Not bleak. Not cynical.

**Visual Direction:** Stylised realism or soft minimalism, strong lighting language, expressive colour shifts, calm environmental storytelling.

**Reference Points:** Journey, Flower (thatgamecompany), Firewatch, Gris.

---

### What This Game Is Not
- Not a grind game
- Not a power fantasy
- Not a collection game
- Not heavily gamified

Mystery and softness are features.

---

### One-Line Summary
A game about becoming someone through the moments you choose to keep.

---

## Part 2 â€” Technical Architecture

### Guiding Code Principles
Every system is written to know as little as possible about other systems. They communicate through **events** (C# Actions). This keeps the project maintainable and means any piece can be rebuilt without breaking others.

### Design Pattern: Singleton Managers
Core systems use the Singleton pattern â€” one instance, globally accessible via `SystemName.Instance`. All live in the `_Persistent` scene and are marked `DontDestroyOnLoad` via the root `--- SYSTEMS ---` object (only the root object calls `DontDestroyOnLoad`; children inherit this automatically).

### Design Pattern: ScriptableObjects for Data
All static game data (memory definitions, trait definitions, moment configs) lives in ScriptableObjects â€” not hardcoded in scripts. This allows designers to tweak values without touching code.

### Design Pattern: Events for Communication
Systems broadcast events when something significant happens. Other systems subscribe to these events rather than polling or calling each other directly.

---

## Part 3 â€” Project Structure

### Folder Layout
```
Assets/
â”œâ”€â”€ _Game/
â”‚   â”œâ”€â”€ Art/
â”‚   â”‚   â”œâ”€â”€ Characters/
â”‚   â”‚   â”œâ”€â”€ Environment/
â”‚   â”‚   â”œâ”€â”€ UI/
â”‚   â”‚   â””â”€â”€ VFX/
â”‚   â”œâ”€â”€ Audio/
â”‚   â”‚   â”œâ”€â”€ Ambient/
â”‚   â”‚   â”œâ”€â”€ Music/
â”‚   â”‚   â””â”€â”€ SFX/
â”‚   â”œâ”€â”€ Materials/
â”‚   â”‚   â”œâ”€â”€ Characters/
â”‚   â”‚   â”œâ”€â”€ Environment/
â”‚   â”‚   â””â”€â”€ PostProcessing/
â”‚   â”œâ”€â”€ Prefabs/
â”‚   â”‚   â”œâ”€â”€ Characters/
â”‚   â”‚   â”œâ”€â”€ Environment/
â”‚   â”‚   â”œâ”€â”€ Memories/
â”‚   â”‚   â”œâ”€â”€ Systems/
â”‚   â”‚   â””â”€â”€ UI/
â”‚   â”œâ”€â”€ Scenes/
â”‚   â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â””â”€â”€ Locations/
â”‚   â”œâ”€â”€ Scripts/
â”‚   â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â”œâ”€â”€ Identity/
â”‚   â”‚   â”œâ”€â”€ Memories/
â”‚   â”‚   â”œâ”€â”€ Player/
â”‚   â”‚   â”œâ”€â”€ Time/
â”‚   â”‚   â”œâ”€â”€ World/
â”‚   â”‚   â””â”€â”€ UI/
â”‚   â””â”€â”€ ScriptableObjects/
â”‚       â”œâ”€â”€ Memories/
â”‚       â”œâ”€â”€ Traits/
â”‚       â””â”€â”€ Moments/
â””â”€â”€ ThirdParty/
```

### Prefab Naming Convention
- `SYS_` â€” system objects (GameManager, AudioManager)
- `ENV_` â€” environment pieces
- `MEM_` â€” memory-related objects
- `UI_` â€” interface elements
- `CHR_` â€” characters

### Scenes
| Scene | Location | Purpose |
|-------|----------|---------|
| `_Boot` | Scenes/Core/ | Entry point, initialises everything |
| `_Persistent` | Scenes/Core/ | Runs forever, holds all global systems |
| `Location_Opening` | Scenes/Locations/ | First playable space |

**Build Settings order:** `_Boot` â†’ `_Persistent` â†’ `Location_Opening`

---

## Part 4 â€” Persistent Scene Hierarchy

```
_Persistent
â””â”€â”€ --- SYSTEMS ---                     (DontDestroyOnLoad set here)
    â”œâ”€â”€ GameManager                     â† GameManager.cs
    â””â”€â”€ MemorySystem                    â† MemorySystem.cs
â””â”€â”€ --- ENVIRONMENT ---
    â””â”€â”€ GlobalPostProcessVolume         â† Prefab: SYS_GlobalPostProcessVolume
```

### Post Processing Volume
Global Volume with profile containing: Color Adjustments, Bloom, Vignette, Depth of Field. Values left at default â€” will be animated by the Emotional Response System (Phase 5).

---

## Part 5 â€” Scripts Reference

### `GameManager.cs`
**Location:** `Assets/_Game/Scripts/Core/`  
**Attached to:** `GameManager` object inside `--- SYSTEMS ---` in `_Persistent`  
**Prefab:** `Assets/_Game/Prefabs/Systems/` (part of `--- SYSTEMS ---` prefab)

**Purpose:** Central nervous system. Tracks game state and broadcasts changes.

**Game States:**
```
Booting        â†’ game is loading
Playing        â†’ normal play (NOTE: temporarily hardcoded to Playing for testing)
Reflecting     â†’ player reviewing memories
Transitioning  â†’ moving between locations
Ending         â†’ final reflection sequence
```

**Key API:**
```csharp
GameManager.Instance.SetGameState(GameState.Playing);
GameManager.Instance.IsPlaying();                        // returns bool
GameManager.Instance.OnGameStateChanged += MyMethod;     // subscribe to state changes
```

**Important note:** `CurrentState` is temporarily initialised to `GameState.Playing` for testing. This will be replaced with a proper boot sequence in a later phase.

---

### `PlayerController.cs`
**Location:** `Assets/_Game/Scripts/Player/`  
**Attached to:** Root `Player` object  
**Prefab:** `Assets/_Game/Prefabs/Characters/PFB_Player`

**Purpose:** First-person movement. Weighted, contemplative feel â€” not snappy or action-oriented.

**Inspector Values (tunable):**
| Field | Default | Effect |
|-------|---------|--------|
| Walk Speed | 3.5 | Lower = contemplative, Higher = purposeful |
| Acceleration | 8 | Lower = dreamy, Higher = responsive |
| Deceleration | 12 | How quickly player stops |
| Jump Force | 4 | |
| Gravity Multiplier | 2.5 | Extra downward force for weight |
| Look Sensitivity | 0.15 | Lower = cinematic, Higher = snappy |
| Vertical Look Clamp | 80 | Degrees up/down |
| Bob Amplitude | 0.04 | Camera bob height while walking |
| Bob Frequency | 1.8 | Bob cycle speed |
| Ground Check Distance | 0.15 | Raycast length for ground detection |

**Dependencies:** `GameManager` (checks `IsPlaying()`), `PlayerInputActions` (generated from Input Action Asset)

**Requires:** `Rigidbody` + `CapsuleCollider` on same object. Player object tagged `Player`. A `Ground` layer assigned to floor geometry.

---

### `CameraController.cs`
**Location:** `Assets/_Game/Scripts/Player/`  
**Attached to:** `PlayerCamera` object (child of `CameraRoot`, child of `Player`)

**Purpose:** Subtle camera life â€” gentle breathing bob and strafe tilt. Makes the world feel inhabited rather than mechanical.

**Dependencies:** `PlayerInputActions`

---

### `MemoryData.cs`
**Location:** `Assets/_Game/Scripts/Memories/`  
**Type:** ScriptableObject  
**Create via:** Right-click in Project â†’ Memory â†’ New Memory  
**Assets stored in:** `Assets/_Game/ScriptableObjects/Memories/`

**Purpose:** Template/definition for what a memory IS. One asset per possible memory in the game.

**Key Fields:**
```csharp
string memoryTitle          // Short poetic phrase: "Swam at midnight"
string memoryDescription    // Longer reflection shown when examined
MemoryCategory category     // Nature, Solitude, Connection, Risk, Creation, Loss, Wonder, Stillness
float emotionalWeight       // 0-1, how strongly this shapes identity
Color worldTintContribution // Phase 7: subtle colour shift added to world
AudioClip ambientLayer      // Phase 7: audio layer unlocked by this memory
TraitType[] reinforcedTraits // Phase 6: traits nudged upward when kept
TraitType[] erodedTraits    // Phase 6: traits quietly reduced when kept
Sprite memoryIcon           // UI icon
Color memoryColour          // UI card tint
```

**Enums defined in this file:**
```csharp
MemoryCategory: Nature, Solitude, Connection, Risk, Creation, Loss, Wonder, Stillness
TraitType: Fearless, Fragile, Curious, Calm, Aware, Warm, Agile, Melancholic, Resilient, Open
```

---

### `MemoryInstance.cs`
**Location:** `Assets/_Game/Scripts/Memories/`  
**Type:** Plain C# class (not MonoBehaviour, not ScriptableObject)

**Purpose:** A memory the player *actually holds* at runtime. Wraps MemoryData with live state (when acquired, vividness, whether reflected on).

**Key Fields:**
```csharp
MemoryData data             // The source template
float timeAcquired          // Game time when memory was formed
bool hasBeenReflectedOn     // Has player examined this in UI
float vividness             // 0-1, fades over game time (used by Identity + UI)
```

**Convenience properties:** `.Title`, `.Description`, `.Category`, `.EmotionalWeight`, `.MemoryColour`, `.Icon`

---

### `MemorySystem.cs`
**Location:** `Assets/_Game/Scripts/Memories/`  
**Attached to:** `MemorySystem` object inside `--- SYSTEMS ---` in `_Persistent`

**Purpose:** Manages all memory slots. Handles keeping, forgetting, replacing. Broadcasts events for all changes.

**Configuration:**
```csharp
int maxMemorySlots = 6      // Adjustable in Inspector (range 3-10)
```

**Key Events (subscribe to these from other systems):**
```csharp
OnMemoryKept(MemoryInstance)                          // A memory was successfully kept
OnMemoryForgotten(MemoryInstance)                     // A memory was let go
OnMemorySlotsFull(MemoryData, List<MemoryInstance>)   // Slots full, player must choose
OnMemoriesChanged()                                   // Any change â€” UI listens to this
```

**Key API:**
```csharp
MemorySystem.Instance.OfferMemory(memoryData)                    // Offer a memory (returns bool)
MemorySystem.Instance.KeepMemory(memoryData)                     // Keep directly
MemorySystem.Instance.ForgetMemory(memoryInstance)               // Let go of a held memory
MemorySystem.Instance.ReplaceMemory(toForget, toKeepData)        // Swap one for another
MemorySystem.Instance.GetAllMemories()                           // Returns List<MemoryInstance>
MemorySystem.Instance.HasFreeSlot()                              // Returns bool
MemorySystem.Instance.HasMemoryOfCategory(category)              // Returns bool
MemorySystem.Instance.GetTotalEmotionalWeight()                  // Returns float
MemorySystem.Instance.GetUsedSlots()                             // Returns int
MemorySystem.Instance.GetSlotCount()                             // Returns int
MemorySystem.Instance.AlreadyHolding(memoryData)                 // Returns bool
```

**Note:** Does NOT call `DontDestroyOnLoad` â€” inherits persistence from root `--- SYSTEMS ---` object.

---

### `MomentTrigger.cs`
**Location:** `Assets/_Game/Scripts/World/`  
**Attached to:** World objects that offer memories  
**Base Prefab:** `Assets/_Game/Prefabs/Memories/MEM_MomentTrigger_Base`

**Purpose:** World object that detects player proximity and offers a memory experience. Uses a SphereCollider trigger. Player must be tagged `Player`.

**Inspector Fields:**
```csharp
MemoryData memoryData       // The memory this moment can create
float triggerRadius = 3f    // How close player needs to be
string promptText           // Interaction hint: "Sit for a while"
float lingerTime = 0f       // If > 0, memory forms after standing here N seconds
bool consumeOnUse = true    // Disappears after experienced (world feels finite)
```

**Events (for UI to subscribe to):**
```csharp
OnPlayerEnterRange(string promptText)   // Show prompt
OnPlayerExitRange()                     // Hide prompt
OnMomentExperienced()                   // Moment was taken
```

**Behaviour:** If `lingerTime > 0`, memory forms automatically after the player stands in range for that duration. Otherwise, player presses `E` (Interact) to take the memory.

**Editor:** Draws a visible gizmo sphere in Scene view so trigger radius is always visible during placement.

---

## Part 6 â€” Input System

**Asset:** `Assets/_Game/Scripts/Core/PlayerInputActions` (Input Action Asset, with C# class generated)

**Action Map: Player**

| Action | Type | Binding | Used By |
|--------|------|---------|---------|
| Move | Value/Vector2 | WASD / Arrow Keys | PlayerController, CameraController |
| Look | Value/Vector2 | Mouse Delta | PlayerController |
| Jump | Button | Space | PlayerController |
| Interact | Button | E | MomentTrigger |
| Reflect | Button | Tab | Phase 4 (Memory UI) |

---

## Part 7 â€” Memory Assets Created

Located in `Assets/_Game/ScriptableObjects/Memories/`

| Asset Name | Title | Category | Weight |
|-----------|-------|----------|--------|
| `MEM_SatByWater` | Sat by the water alone | Stillness | 0.6 |
| `MEM_StoodOnHighGround` | Stood somewhere high and looked out | Wonder | 0.7 |
| `MEM_WalkedIntoRain` | Walked into the rain without shelter | Risk | 0.5 |
| `MEM_WatchedSunMove` | Watched the light change | Stillness | 0.4 |
| `MEM_FoundHiddenPlace` | Found somewhere nobody else knew | Solitude | 0.8 |

---

## Part 8 â€” Player Prefab Structure

```
Player (root)                   â† PlayerController.cs, Rigidbody, CapsuleCollider
â”‚                                  Tag: Player
â”‚                                  Rigidbody: Mass 70, Drag 5, Angular Drag 999
â”‚                                  Freeze Rotation X Y Z
â”‚                                  Capsule: Height 1.8, Radius 0.4, Center Y 0.9
â”‚
â”œâ”€â”€ CameraRoot                  â† Y position: 1.7 (eye height)
â”‚   â””â”€â”€ PlayerCamera            â† Camera component, CameraController.cs
â”‚                                  Tagged: MainCamera
â””â”€â”€ BodyRoot                    â† Future: body sway, breathing animations
```

**Prefab saved as:** `Assets/_Game/Prefabs/Characters/PFB_Player`

---

## Part 9 â€” Systems Architecture Overview

```
Layer 1 â€” Data
  MemoryData (ScriptableObject)     â†’ defines what a memory IS
  TraitType (enum)                  â†’ categories of identity
  MemoryCategory (enum)             â†’ types of experience

Layer 2 â€” Runtime State
  MemoryInstance (C# class)         â†’ a memory the player currently holds

Layer 3 â€” Managers (Persistent)
  GameManager                       â†’ game state, global flow
  MemorySystem                      â†’ slots, keep/forget logic, events

Layer 4 â€” World Objects (per scene)
  MomentTrigger                     â†’ offers memories from the environment

Layer 5 â€” Player (per scene)
  PlayerController                  â†’ movement
  CameraController                  â†’ camera feel

Layer 6 â€” UI (Phase 4)
  MemorySlotUI                      â†’ visual representation of held memories
  MomentPromptUI                    â†’ "press E" style prompts

Layer 7 â€” Identity System (Phase 6)
  Reads MemorySystem
  Derives traits from held memories
  Alters player abilities/perception

Layer 8 â€” World Echo System (Phase 7)
  Reads MemorySystem
  Alters post processing, ambient audio, world warmth
  Makes the world reflect lived experience

Layer 9 â€” Time System (Phase 7)
  Replaces gameTime float in MemorySystem
  Shifts world state, closes/opens possibilities

Layer 10 â€” Ending System (Phase 8)
  Reads all held memories + identity
  Generates reflective ending sequence
```

---

## Part 10 â€” Build Phases Roadmap

| Phase | Focus | Status |
|-------|-------|--------|
| 1 | Project setup, folder structure, scenes, GameManager, Git | âœ… Complete |
| 2 | Player first-person controller, weighted movement, camera bob | âœ… Complete |
| 3 | Memory system â€” data layer, MemoryData, MemoryInstance, MemorySystem, MomentTrigger | âœ… Complete |
| 4 | Memory UI â€” visible slots, moment prompts, replace/forget choice screen | â³ Next |
| 5 | Emotional response system â€” post processing, audio, world reactions to moments | ğŸ”² Pending |
| 6 | Identity/trait system â€” traits derived from memories, altering movement/perception | ğŸ”² Pending |
| 7 | Time system + world echo â€” world shifts to reflect lived experience | ğŸ”² Pending |
| 8 | Ending/reflection sequence â€” memory collage, epilogue, reflective finale | ğŸ”² Pending |

**Rule:** Each phase should *feel like something* before moving to the next. Don't start Phase 4 until Phase 3 is working and satisfying in testing.

---

## Part 11 â€” Known Issues & Notes

- `GameManager.CurrentState` is temporarily initialised to `GameState.Playing` to allow testing without a boot sequence. This will be replaced in a later phase.
- `isLingering` field was removed from `MomentTrigger.cs` (was assigned but never read â€” will be reintroduced when the UI linger progress indicator is built in Phase 4).
- No UI exists yet â€” all feedback is via the Unity Console (`Debug.Log`).
- `MemorySystem.gameTime` is a simple float counter. It will be replaced by a proper `TimeSystem` in Phase 7.

---

## Part 12 â€” Version Control

- **Platform:** GitHub
- **Tool:** GitHub Desktop (recommended for commits/pushes)
- **Commit rhythm:** End of every session â€” short descriptive message, commit, push
- **.gitignore:** Official Unity gitignore in place at project root
- **Unity settings:** Asset Serialization â†’ Force Text, Version Control â†’ Visible Meta Files

**Commit history so far:**
1. Initial project setup
2. Phase 2: Player controller with weighted movement and camera bob
3. Phase 3: Memory system â€” data layer, moment triggers, first memories

---

*Last updated: Phase 3 complete. Next: Phase 4 â€” Memory UI.*